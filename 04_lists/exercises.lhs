% -*- mode: LaTeX -*-

\documentclass{article}

\usepackage{fullpage}
\usepackage{enumitem}
\usepackage{verbatim}
\usepackage{url}
\usepackage{hyperref}

%include rae.fmt

\begin{document}

\begin{comment}
\begin{code}
import Prelude hiding (zipWith, tail, even, takeWhile)
\end{code}
\end{comment}

\begin{center}
\bf
CS380: Modern Functional Programming\\
Prof. Richard Eisenberg\\
Spring 2017\\[1ex]
Lists
\end{center}

Use list comprehensions to solve these problems. 
They are taken from \url{http://projecteuler.net}; they are problems 1 and 2.

The following definitions from the Haskell standard library will be helpful:

\begin{code}
-- |sum xs| calculates the sum of all the elements in |xs|. Thus, |sum [1,2,3]| equals |6|.
sum :: Num a => [a] -> a

-- |zipWith f xs ys| applies the function |f| to corresponding elements in |xs| and |ys|.
-- Thus, |zipWith (-) [4,7,10] [1,2,3]| equals |[3,5,7]|. If one list is longer than the
-- other, the extra elements in the longer list are ignored.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- |tail xs| removes the first element from the list |xs| and returns the remainder.
-- Thus, |tail [1,2,3]| equals |[2,3]|. |tail| errors if the list is empty.
tail :: [a] -> [a]

-- |even x| is a predicate that determines whether or not |x| is even. Thus,
-- |even 4| is |True| while |even 9| is |False|.
even :: Integral a => a -> Bool

-- |takeWhile f xs| returns the longest prefix of the list |xs| such that every
-- element in the prefix satisfies predicate |f|. Thus, |takeWhile (< 3) [1,2,3,4,1,2,3]|
-- equals |[1,2]|.
takeWhile :: (a -> Bool) -> [a] -> [a]
\end{code}

%if style == newcode
\begin{code}
sum = foldr (+) 0

zipWith f (x:xs) (y:ys) = f x y : zipWith f xs ys
zipWith _ _ _ = []

tail (_:xs) = xs
tail _ = error "tail of empty list"

even = (== 0) . (`mod` 2)

takeWhile f (x:xs)
  | f x = x : takeWhile f xs
  | otherwise = []
takeWhile _ _ = []
\end{code}
%endif

\begin{enumerate}
\item
If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.

Write an expression that evaluates to the sum of all the multiples of 3 or 5 below 1000.

\vspace{1in}

\item 
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: $1, 2, 3, 5, 8, 13, 21, 34, 55, 89, \ldots$

We can define the infinite list of Fibonacci numbers in Haskell with

\begin{code}
fibs :: [Integer]
fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
\end{code}

By considering the terms in the Fibonacci sequence whose values do not exceed four million, write
an expression that evaluates to the sum of the even-valued terms.
\end{enumerate}

\end{document}
